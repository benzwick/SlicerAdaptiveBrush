"""MFEM volumetric NURBS mesh export.

Exports volumetric NURBS to MFEM mesh format v1.0 for use in
isogeometric analysis (IGA) simulations.

MFEM NURBS mesh format:
- Text-based format
- Supports 3D hexahedral NURBS elements
- Includes knot vectors and weights
- Multi-patch support with connectivity

References:
- MFEM Mesh Formats: https://mfem.org/mesh-formats/
- MFEM NURBS Examples: https://mfem.org/examples/
"""

from __future__ import annotations

import logging
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..NurbsVolumeBuilder import MultiPatchNurbsVolume, NurbsVolume

logger = logging.getLogger(__name__)


class MfemExporter:
    """Export NURBS volumes to MFEM mesh format.

    Example:
        exporter = MfemExporter()
        exporter.export(nurbs_volume, Path("output.mesh"))
    """

    # MFEM element types
    ELEMENT_NURBS_SEGMENT = 21  # 2D NURBS patch (for boundary)
    ELEMENT_NURBS_PATCH = 25  # 3D NURBS element

    def __init__(self):
        """Initialize MFEM exporter."""
        pass

    def export(
        self,
        nurbs_volume: NurbsVolume,
        output_path: Path,
        boundary_attributes: dict[str, int] | None = None,
    ) -> None:
        """Export a single-patch NURBS volume to MFEM format.

        Args:
            nurbs_volume: The NURBS volume to export.
            output_path: Path to write .mesh file.
            boundary_attributes: Optional boundary condition attributes.
        """
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)

        with open(output_path, "w") as f:
            self._write_header(f)
            self._write_dimension(f, 3)
            self._write_elements(f, nurbs_volume)
            self._write_boundary(f, nurbs_volume, boundary_attributes)
            self._write_knot_vectors(f, nurbs_volume)
            self._write_weights(f, nurbs_volume)
            self._write_control_points(f, nurbs_volume)

        logger.info(f"Exported MFEM mesh: {output_path}")

    def export_multi_patch(
        self,
        multi_patch: MultiPatchNurbsVolume,
        output_path: Path,
    ) -> None:
        """Export a multi-patch NURBS volume to MFEM format.

        Args:
            multi_patch: The multi-patch NURBS volume.
            output_path: Path to write .mesh file.
        """
        # For multi-patch, we need to handle connectivity
        # MFEM supports this through shared edges/faces

        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)

        with open(output_path, "w") as f:
            self._write_header(f)
            self._write_dimension(f, 3)

            # Write elements for each patch
            f.write(f"\nelements\n{multi_patch.num_patches}\n")
            for i, patch in enumerate(multi_patch.patches):
                # Element line: attribute type vertex_indices...
                nu, nv, nw = patch.size
                n_verts = nu * nv * nw
                # Use patch index as vertex offset
                vert_offset = sum(p.num_control_points for p in multi_patch.patches[:i])
                vert_indices = " ".join(str(vert_offset + j) for j in range(n_verts))
                f.write(f"1 {self.ELEMENT_NURBS_PATCH} {vert_indices}\n")

            # Write boundaries (all exterior faces)
            self._write_multi_patch_boundary(f, multi_patch)

            # Write knot vectors for all patches
            self._write_multi_patch_knot_vectors(f, multi_patch)

            # Write all weights
            self._write_multi_patch_weights(f, multi_patch)

            # Write all control points
            self._write_multi_patch_control_points(f, multi_patch)

        logger.info(f"Exported multi-patch MFEM mesh: {output_path}")

    def _write_header(self, f) -> None:
        """Write MFEM mesh header."""
        f.write("MFEM NURBS mesh v1.0\n")
        f.write("\n# Generated by SlicerAdaptiveBrushNurbs\n")

    def _write_dimension(self, f, dim: int) -> None:
        """Write mesh dimension."""
        f.write(f"\ndimension\n{dim}\n")

    def _write_elements(self, f, nurbs_volume: NurbsVolume) -> None:
        """Write element definitions."""
        f.write("\n# Single hexahedral NURBS element\n")
        f.write("elements\n1\n")

        # For a single hexahedral element, vertices are all control points
        # Listed in order: varying w fastest, then v, then u
        nu, nv, nw = nurbs_volume.size
        n_verts = nu * nv * nw

        # MFEM element format: attribute type vertex_indices...
        # attribute = 1 (material/region ID)
        # type = 25 (3D NURBS)
        vert_indices = " ".join(str(i) for i in range(n_verts))
        f.write(f"1 {self.ELEMENT_NURBS_PATCH} {vert_indices}\n")

    def _write_boundary(
        self,
        f,
        nurbs_volume: NurbsVolume,
        attributes: dict[str, int] | None,
    ) -> None:
        """Write boundary face definitions."""
        f.write("\n# 6 boundary faces (2D NURBS patches)\n")
        f.write("boundary\n6\n")

        nu, nv, nw = nurbs_volume.size

        # Default boundary attributes
        if attributes is None:
            attributes = {
                "u0": 1,
                "u1": 2,
                "v0": 3,
                "v1": 4,
                "w0": 5,
                "w1": 6,
            }

        # Helper to get vertex indices for a face
        def get_face_indices(face: str) -> list[int]:
            """Get control point indices for a boundary face."""
            indices = []
            if face == "u0":  # First u layer
                for j in range(nv):
                    for k in range(nw):
                        indices.append(0 * nv * nw + j * nw + k)
            elif face == "u1":  # Last u layer
                for j in range(nv):
                    for k in range(nw):
                        indices.append((nu - 1) * nv * nw + j * nw + k)
            elif face == "v0":  # First v layer
                for i in range(nu):
                    for k in range(nw):
                        indices.append(i * nv * nw + 0 * nw + k)
            elif face == "v1":  # Last v layer
                for i in range(nu):
                    for k in range(nw):
                        indices.append(i * nv * nw + (nv - 1) * nw + k)
            elif face == "w0":  # First w layer
                for i in range(nu):
                    for j in range(nv):
                        indices.append(i * nv * nw + j * nw + 0)
            elif face == "w1":  # Last w layer
                for i in range(nu):
                    for j in range(nv):
                        indices.append(i * nv * nw + j * nw + (nw - 1))
            return indices

        # Write each face
        for face in ["u0", "u1", "v0", "v1", "w0", "w1"]:
            attr = attributes.get(face, 1)
            indices = get_face_indices(face)
            indices_str = " ".join(str(i) for i in indices)
            f.write(f"{attr} {self.ELEMENT_NURBS_SEGMENT} {indices_str}\n")

    def _write_knot_vectors(self, f, nurbs_volume: NurbsVolume) -> None:
        """Write knot vectors for each parametric direction."""
        knot_u, knot_v, knot_w = nurbs_volume.knot_vectors
        degree = nurbs_volume.degree

        f.write("\n# 3 knot vectors (one per parametric direction u,v,w)\n")
        f.write("knotvectors\n3\n")

        # Format: degree num_knots knot_values...
        for knots in [knot_u, knot_v, knot_w]:
            n_knots = len(knots)
            knots_str = " ".join(f"{k:.10g}" for k in knots)
            f.write(f"{degree} {n_knots} {knots_str}\n")

    def _write_weights(self, f, nurbs_volume: NurbsVolume) -> None:
        """Write control point weights."""
        weights = nurbs_volume.weights.flatten()
        n_weights = len(weights)

        f.write(f"\n# {n_weights} weights ({nurbs_volume.size[0]}x")
        f.write(f"{nurbs_volume.size[1]}x{nurbs_volume.size[2]} control points)\n")
        f.write("weights\n")
        f.write(f"{n_weights}\n")

        # Write weights in order
        for w in weights:
            f.write(f"{w:.10g}\n")

    def _write_control_points(self, f, nurbs_volume: NurbsVolume) -> None:
        """Write control point coordinates."""
        control_points = nurbs_volume.control_points
        len(control_points)

        f.write("\n# Control point coordinates\n")
        f.write("FiniteElementSpace\n")
        f.write("FiniteElementCollection: NURBS3\n")
        f.write("VDim: 3\n")
        f.write("Ordering: 1\n")
        f.write("\n")

        # Write control points (x y z per line)
        for pt in control_points:
            f.write(f"{pt[0]:.10g} {pt[1]:.10g} {pt[2]:.10g}\n")

    def _write_multi_patch_boundary(self, f, multi_patch: MultiPatchNurbsVolume) -> None:
        """Write boundary for multi-patch mesh."""
        # For multi-patch, only exterior faces are boundaries
        # Interior shared faces are not written

        # For simplicity, write all faces (TODO: exclude shared faces)
        n_faces = multi_patch.num_patches * 6

        f.write(f"\nboundary\n{n_faces}\n")

        vert_offset = 0
        for _patch_idx, patch in enumerate(multi_patch.patches):
            nu, nv, nw = patch.size

            for face_idx, face in enumerate(["u0", "u1", "v0", "v1", "w0", "w1"]):
                # Get face indices with offset
                indices = self._get_face_indices_with_offset(patch, face, vert_offset)
                attr = face_idx + 1
                indices_str = " ".join(str(i) for i in indices)
                f.write(f"{attr} {self.ELEMENT_NURBS_SEGMENT} {indices_str}\n")

            vert_offset += patch.num_control_points

    def _write_multi_patch_knot_vectors(self, f, multi_patch: MultiPatchNurbsVolume) -> None:
        """Write knot vectors for all patches."""
        n_knot_vectors = multi_patch.num_patches * 3

        f.write(f"\nknotvectors\n{n_knot_vectors}\n")

        for patch in multi_patch.patches:
            degree = patch.degree
            for knots in patch.knot_vectors:
                n_knots = len(knots)
                knots_str = " ".join(f"{k:.10g}" for k in knots)
                f.write(f"{degree} {n_knots} {knots_str}\n")

    def _write_multi_patch_weights(self, f, multi_patch: MultiPatchNurbsVolume) -> None:
        """Write weights for all patches."""
        total_weights = multi_patch.total_control_points

        f.write(f"\nweights\n{total_weights}\n")

        for patch in multi_patch.patches:
            for w in patch.weights.flatten():
                f.write(f"{w:.10g}\n")

    def _write_multi_patch_control_points(self, f, multi_patch: MultiPatchNurbsVolume) -> None:
        """Write control points for all patches."""
        f.write("\nFiniteElementSpace\n")
        f.write("FiniteElementCollection: NURBS3\n")
        f.write("VDim: 3\n")
        f.write("Ordering: 1\n\n")

        for patch in multi_patch.patches:
            for pt in patch.control_points:
                f.write(f"{pt[0]:.10g} {pt[1]:.10g} {pt[2]:.10g}\n")

    def _get_face_indices_with_offset(
        self,
        patch: NurbsVolume,
        face: str,
        offset: int,
    ) -> list[int]:
        """Get face indices with vertex offset for multi-patch."""
        nu, nv, nw = patch.size
        indices = []

        if face == "u0":
            for j in range(nv):
                for k in range(nw):
                    indices.append(offset + j * nw + k)
        elif face == "u1":
            for j in range(nv):
                for k in range(nw):
                    indices.append(offset + (nu - 1) * nv * nw + j * nw + k)
        elif face == "v0":
            for i in range(nu):
                for k in range(nw):
                    indices.append(offset + i * nv * nw + k)
        elif face == "v1":
            for i in range(nu):
                for k in range(nw):
                    indices.append(offset + i * nv * nw + (nv - 1) * nw + k)
        elif face == "w0":
            for i in range(nu):
                for j in range(nv):
                    indices.append(offset + i * nv * nw + j * nw)
        elif face == "w1":
            for i in range(nu):
                for j in range(nv):
                    indices.append(offset + i * nv * nw + j * nw + (nw - 1))

        return indices
